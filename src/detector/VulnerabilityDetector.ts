/**
 * Vulnerability Detector Engine
 * Runs all vulnerability detection rules against parsed contracts
 */

import { ParsedContract, Vulnerability, AuditOptions } from '../types';
import { vulnerabilityRules } from './rules';
import { logger } from '../utils/logger';

export class VulnerabilityDetector {
  /**
   * Detect vulnerabilities in parsed contract
   */
  async detect(
    parsedContract: ParsedContract,
    options: AuditOptions = {}
  ): Promise<Vulnerability[]> {
    logger.info('Starting vulnerability detection');

    const allVulnerabilities: Vulnerability[] = [];
    const rulesToRun = options.skipRules
      ? vulnerabilityRules.filter(rule => !options.skipRules!.includes(rule.id))
      : vulnerabilityRules;

    // Add custom rules if provided
    const finalRules = options.customRules
      ? [...rulesToRun, ...options.customRules]
      : rulesToRun;

    for (const rule of finalRules) {
      try {
        const vulnerabilities = this.applyRule(rule, parsedContract);
        allVulnerabilities.push(...vulnerabilities);
        logger.debug(`Rule ${rule.id}: Found ${vulnerabilities.length} issues`);
      } catch (error: any) {
        logger.error(`Error applying rule ${rule.id}`, { error: error.message });
      }
    }

    logger.info(`Total vulnerabilities detected: ${allVulnerabilities.length}`);

    return this.deduplicateVulnerabilities(allVulnerabilities);
  }

  /**
   * Apply a single rule
   */
  private applyRule(rule: any, parsedContract: ParsedContract): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check if pattern is a function or RegExp
    if (typeof rule.pattern === 'function') {
      // Rule uses AST analysis
      for (const metadata of parsedContract.metadata) {
        const found = rule.pattern(parsedContract.ast, metadata);
        vulnerabilities.push(...found);
      }
    } else if (rule.pattern instanceof RegExp) {
      // Rule uses regex pattern matching
      const matches = parsedContract.sourceCode.match(rule.pattern);
      if (matches) {
        for (const match of matches) {
          vulnerabilities.push(this.createVulnerabilityFromRegex(rule, match, parsedContract.sourceCode));
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Create vulnerability from regex match
   */
  private createVulnerabilityFromRegex(
    rule: any,
    match: string,
    sourceCode: string
  ): Vulnerability {
    const index = sourceCode.indexOf(match);
    const lines = sourceCode.substring(0, index).split('\n');
    const line = lines.length;

    return {
      id: rule.id,
      name: rule.name,
      severity: rule.severity,
      description: rule.description,
      location: {
        file: 'contract.sol',
        line,
        column: lines[lines.length - 1].length
      },
      technicalExplanation: `Detected usage of ${match}`,
      exploitScenario: 'See references for potential exploits',
      recommendation: rule.recommendation,
      codeSnippet: this.extractCodeSnippet(sourceCode, line),
      references: rule.references,
      confidence: 0.75
    };
  }

  /**
   * Extract code snippet around line number
   */
  private extractCodeSnippet(sourceCode: string, lineNumber: number): string {
    const lines = sourceCode.split('\n');
    const start = Math.max(0, lineNumber - 3);
    const end = Math.min(lines.length, lineNumber + 2);
    return lines.slice(start, end).join('\n');
  }

  /**
   * Remove duplicate vulnerabilities
   */
  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    const unique: Vulnerability[] = [];

    for (const vuln of vulnerabilities) {
      const key = `${vuln.id}:${vuln.location.line}:${vuln.location.column}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(vuln);
      }
    }

    return unique;
  }
}
